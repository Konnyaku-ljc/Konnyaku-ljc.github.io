<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2"/>























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=6.7.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="基础算法详解蒟蒻将转载（书写）一些自己学习代码时的学习参考文章以及自己写的文章，如有冒犯，请多包涵…… 本文章用Typora书写，推荐使用博客阅读">
<meta property="og:type" content="article">
<meta property="og:title" content="基础算法详解">
<meta property="og:url" content="http://yoursite.com/2020/03/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Konnyaku-ljc&#39;s Blog">
<meta property="og:description" content="基础算法详解蒟蒻将转载（书写）一些自己学习代码时的学习参考文章以及自己写的文章，如有冒犯，请多包涵…… 本文章用Typora书写，推荐使用博客阅读">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.luogu.org/upload/pic/25108.png">
<meta property="og:image" content="https://i.loli.net/2018/07/25/5b583277e47e9.png">
<meta property="og:image" content="https://i.loli.net/2018/07/25/5b58347b9a37b.png">
<meta property="og:image" content="https://i.loli.net/2018/07/25/5b586fa8de335.png">
<meta property="og:image" content="https://i.loli.net/2018/07/25/5b58703e8d0d6.png">
<meta property="og:image" content="https://i.loli.net/2018/07/25/5b58724845b8d.png">
<meta property="og:image" content="https://cdn.luogu.org/upload/pic/28090.png">
<meta property="og:image" content="https://cdn.luogu.org/upload/pic/28091.png">
<meta property="og:image" content="https://i.loli.net/2019/08/26/5ZIFzj61PsmCHXu.png">
<meta property="og:image" content="https://i.loli.net/2019/08/26/vZ736TwSGcEbNtF.png">
<meta property="og:image" content="https://i.loli.net/2019/08/23/1jY6ef2mBqQD8NL.png">
<meta property="og:image" content="https://i.loli.net/2019/08/23/7x932FdlyDpMSRW.png">
<meta property="og:image" content="https://i.loli.net/2019/08/23/afMQgrGOyXpE2DC.png">
<meta property="og:image" content="http://p0.so.qhimgs1.com/bdr/_240_/t01b3cd94b11782f024.png">
<meta property="og:image" content="http://p0.so.qhimgs1.com/bdr/_240_/t016b0d2e51e372bef0.png">
<meta property="og:image" content="https://img-blog.csdn.net/20170816154142793?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU5MTQ1ODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-de25f47ce1af774c75d9b0a60fb816fc_hd.jpg">
<meta property="article:published_time" content="2020-03-14T09:19:59.425Z">
<meta property="article:modified_time" content="2020-03-14T12:05:50.003Z">
<meta property="article:author" content="Konnyaku_ljc">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.luogu.org/upload/pic/25108.png">






  <link rel="canonical" href="http://yoursite.com/2020/03/14/基础算法详解/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>基础算法详解 | Konnyaku-ljc's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Konnyaku-ljc's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Metroidvania深度爱好者</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    

    

    <a href="/" rel="section">首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    

    

    <a href="/about/" rel="section">关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    

    

    <a href="/tags/" rel="section">标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    

    

    <a href="/categories/" rel="section">分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    

    

    <a href="/archives/" rel="section">归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Konnyaku_ljc"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/head.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Konnyaku-ljc's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">基础算法详解

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-03-14 17:19:59 / 修改时间：20:05:50" itemprop="dateCreated datePublished" datetime="2020-03-14T17:19:59+08:00">2020-03-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/learn/" itemprop="url" rel="index"><span itemprop="name">learn</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="基础算法详解"><a href="#基础算法详解" class="headerlink" title="基础算法详解"></a>基础算法详解</h1><p>蒟蒻将转载（书写）一些自己学习代码时的学习参考文章以及自己写的文章，如有冒犯，请多包涵……</p>
<p>本文章用<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a>书写，推荐<a href="https://konnyaku-ljc.github.io" target="_blank" rel="noopener">使用博客阅读</a>   </p>
<a id="more"></a>

<ul>
<li><h5 id="2019-8-8-鸽了，以后每天都不鸽！（真香qwq）-逃"><a href="#2019-8-8-鸽了，以后每天都不鸽！（真香qwq）-逃" class="headerlink" title="2019/8/8 鸽了，以后每天都不鸽！（真香qwq）(逃"></a>2019/8/8 鸽了，以后每天都不鸽！（真香qwq）(逃</h5></li>
<li><h5 id="2019-8-9-开始更新"><a href="#2019-8-9-开始更新" class="headerlink" title="2019/8/9 开始更新"></a>2019/8/9 开始更新</h5></li>
<li><h5 id="2019-8-9-加入ST表"><a href="#2019-8-9-加入ST表" class="headerlink" title="2019/8/9 加入ST表"></a>2019/8/9 加入ST表</h5></li>
<li><h5 id="2019-8-9-加入深度优先搜索（DFS）"><a href="#2019-8-9-加入深度优先搜索（DFS）" class="headerlink" title="2019/8/9 加入深度优先搜索（DFS）"></a>2019/8/9 加入深度优先搜索（DFS）</h5></li>
<li><h5 id="2019-8-9-加入SPFA（虽然它死了……）"><a href="#2019-8-9-加入SPFA（虽然它死了……）" class="headerlink" title="2019/8/9 加入SPFA（虽然它死了……）"></a>2019/8/9 加入SPFA（虽然它死了……）</h5></li>
<li><h5 id="2019-8-10-加入dijkstra"><a href="#2019-8-10-加入dijkstra" class="headerlink" title="2019/8/10 加入dijkstra"></a>2019/8/10 加入dijkstra</h5></li>
<li><h5 id="2019-8-11-加入Floyd"><a href="#2019-8-11-加入Floyd" class="headerlink" title="2019/8/11 加入Floyd"></a>2019/8/11 加入Floyd</h5></li>
<li><h5 id="2019-8-13-加入KMP"><a href="#2019-8-13-加入KMP" class="headerlink" title="2019/8/13 加入KMP"></a>2019/8/13 加入KMP</h5></li>
<li><h5 id="2019-8-13-加入自动AC机"><a href="#2019-8-13-加入自动AC机" class="headerlink" title="2019/8/13 加入自动AC机"></a>2019/8/13 加入自动AC机</h5></li>
<li><h5 id="2019-8-23-加入并查集"><a href="#2019-8-23-加入并查集" class="headerlink" title="2019/8/23 加入并查集"></a>2019/8/23 加入并查集</h5></li>
<li><h5 id="2019-8-24-加入广度优先搜索（BFS）"><a href="#2019-8-24-加入广度优先搜索（BFS）" class="headerlink" title="2019/8/24 加入广度优先搜索（BFS）"></a>2019/8/24 加入广度优先搜索（BFS）</h5></li>
<li><h5 id="2019-8-24-加入状压DP"><a href="#2019-8-24-加入状压DP" class="headerlink" title="2019/8/24 加入状压DP"></a>2019/8/24 加入状压DP</h5></li>
<li><h5 id="2019-8-24-加入矩阵快速幂"><a href="#2019-8-24-加入矩阵快速幂" class="headerlink" title="2019/8/24 加入矩阵快速幂"></a>2019/8/24 加入矩阵快速幂</h5></li>
<li><h5 id="2019-8-25-加入乘法逆元"><a href="#2019-8-25-加入乘法逆元" class="headerlink" title="2019/8/25 加入乘法逆元"></a>2019/8/25 加入乘法逆元</h5></li>
<li><h5 id="2019-8-26-加入树状数组"><a href="#2019-8-26-加入树状数组" class="headerlink" title="2019/8/26 加入树状数组"></a>2019/8/26 加入树状数组</h5></li>
<li><h5 id="2019-8-26-加入线段树"><a href="#2019-8-26-加入线段树" class="headerlink" title="2019/8/26 加入线段树"></a>2019/8/26 加入线段树</h5></li>
<li><h5 id="2019-8-26-加入树形DP"><a href="#2019-8-26-加入树形DP" class="headerlink" title="2019/8/26 加入树形DP"></a>2019/8/26 加入树形DP</h5></li>
<li><h5 id="2019-8-29-加入Prim"><a href="#2019-8-29-加入Prim" class="headerlink" title="2019/8/29 加入Prim"></a>2019/8/29 加入Prim</h5></li>
<li><h5 id="2019-8-29-加入Kruskal"><a href="#2019-8-29-加入Kruskal" class="headerlink" title="2019/8/29 加入Kruskal"></a>2019/8/29 加入Kruskal</h5></li>
</ul>
<h3 id="完美AC方法"><a href="#完美AC方法" class="headerlink" title="完美AC方法"></a>完美AC方法</h3><h4 id="自动AC机"><a href="#自动AC机" class="headerlink" title="自动AC机"></a>自动AC机</h4><p>本题可以以任何题为模板</p>
<ol>
<li><p>功能</p>
<p>rt，自动AC（NOIP、NOI、IOI、不可用）</p>
</li>
<li><p>算法解释</p>
<p>利用计算机系统BUG，反向读取数据，再输出，达到自动AC的目的</p>
</li>
<li><p>算法解析</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c,id,n,m,l;</span><br><span class="line">    freopen(<span class="string">"**.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);<span class="comment">//文件名</span></span><br><span class="line">    freopen(<span class="string">"**.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);<span class="comment">//文件名</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;l);</span><br><span class="line">    fclose(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(s,<span class="string">"..\\..\\data\\**\\**%d.in"</span>,i);</span><br><span class="line">        freopen(s,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="keyword">if</span> (a==n&amp;&amp;b==m&amp;&amp;c==l)</span><br><span class="line">        &#123;</span><br><span class="line">            id=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(<span class="built_in">stdin</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sprintf</span>(s,<span class="string">"..\\..\\data\\**\\**%d.out"</span>,id);</span><br><span class="line">    freopen(s,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ans;<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好像可以用，同学模拟赛A了两道题，被老师发现（<del>老师不相信他能ACT3</del> 他T1没A，A了T2T3，老师惊了）</p>
</li>
</ol>
<h3 id="基础暴力算法"><a href="#基础暴力算法" class="headerlink" title="基础暴力算法"></a>基础暴力算法</h3><h4 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h4><p>本篇章以 <a href="https://www.luogu.org/problem/P4961" target="_blank" rel="noopener">luogu P4961 小埋与扫雷</a>为例题讲解。</p>
<ol>
<li><p>功能</p>
<p>过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次.</p>
</li>
<li><p>算法解释</p>
<p>从图中某顶点v出发：</p>
<p>访问顶点v，依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问，若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</p>
</li>
<li><p>代码实现</p>
<p>由题意知，我们需要对周围有雷的点一次，没雷且连在一起的的总共点一次，我们要搜索的，便是连在一起的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> X[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;<span class="comment">//因为是八连通 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Y[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">// 所以八个方向 </span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>][<span class="number">1005</span>];<span class="comment">// 图 </span></span><br><span class="line"><span class="keyword">int</span> n,m,ans;<span class="comment">// ans代表点击数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//搜索 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[x][y]=<span class="number">3</span>;<span class="comment">//周围没雷，但是跑了 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//八个方向，八次循环</span></span><br><span class="line">        <span class="keyword">if</span>(x+X[i]&gt;=<span class="number">1</span>&amp;&amp;x+X[i]&lt;=n&amp;&amp;y+Y[i]&gt;=<span class="number">1</span>&amp;&amp;y+Y[i]&lt;=m)</span><br><span class="line">        <span class="comment">//剪枝，在图的范围内；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[x+X[i]][y+Y[i]])<span class="comment">//剪枝，此点没有走过时 </span></span><br><span class="line">            dfs(x+X[i],y+Y[i]);<span class="comment">//搜索此点</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;<span class="comment">//输入 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i][j];<span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[i][j])<span class="comment">//如果本身不是雷，判断周围有没有雷 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;<span class="number">8</span>;l++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i+X[l]][j+Y[l]]==<span class="number">1</span>)</span><br><span class="line">                <span class="comment">//如果这个点已经跑过一次</span></span><br><span class="line">                a[i][j]=<span class="number">2</span>;<span class="comment">//并且周围有雷的话，a[i][j]=2 </span></span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="number">2</span>)<span class="comment">//如果周围有雷 </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> wa=<span class="number">1</span>;<span class="comment">//用wa进行判断 </span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;<span class="number">8</span>;l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i+X[l]][j+Y[l]]==<span class="number">0</span>&amp;&amp;i+X[l]&gt;=<span class="number">1</span>&amp;&amp;i+X[l]&lt;=n&amp;&amp;j+Y[l]&gt;=<span class="number">1</span>&amp;&amp;j+Y[l]&lt;=m)</span><br><span class="line">                    wa=<span class="number">0</span>;<span class="comment">//如果周围没雷且在图内，wa=0； </span></span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="keyword">if</span>(wa==<span class="number">1</span>)ans++;<span class="comment">// 如果不合上文，就要多点一次</span></span><br><span class="line">            &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">if</span>(!a[i][j])<span class="comment">//如果没有走</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs(i,j);<span class="comment">// 搜索 </span></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;<span class="comment">//AC</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h4><p><del>我刚学会</del> 好吧，平时天天写DFS，BFS好不容易找了道例题</p>
<p>本篇章以<a href="luogu.org/problem/P1126">luogu P1126 机器人搬重物</a>为例题</p>
<ol>
<li><p>功能</p>
<p>Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。</p>
</li>
<li><p>算法解释</p>
<p>已知图G=(V,E)和一个源顶点s，广度优先搜索以一种系统的方式探寻G的边，从而“发现”s所能到达的所有顶点，并计算s到所有这些顶点的距离(最少边数)，该算法同时能生成一棵根为s且包括所有可达顶点的宽度优先树。对从s可达的任意顶点v，宽度优先树中从s到v的路径对应于图G中从s到v的最短路径，即包含最小边数的路径。该算法对有向图和无向图同样适用。之所以称之为宽度优先算法，是因为算法自始至终一直通过已找到和未找到顶点之间的边界向外扩展，就是说，算法首先搜索和s距离为k的所有顶点，然后再去搜索和S距离为k+l的其他顶点。</p>
<p>在广度优先搜索过程中建立了一棵宽度优先树，起始时只包含根节点，即源顶点s.在扫描已发现顶点u的邻接表的过程中每发现一个白色顶点v，该顶点v及边(u,v)就被添加到树中。在宽度优先树中，我们称结点u 是结点v的先辈或父母结点。因为一个结点至多只能被发现一次，因此它最多只能有–个父母结点。相对根结点来说祖先和后裔关系的定义和通常一样：如果u处于树中从根s到结点v的路径中，那么u称为v的祖先，v是u的后裔。</p>
</li>
<li><p>代码</p>
<p>其实不像个广搜，像个模拟。。。去掉那些冗长的东西就好了qwq</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">55</span>][<span class="number">55</span>],f[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,x,orz,x1,emmm,x2,y2;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> fx[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> fy[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> X[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Y[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> hh[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ )</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++ )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">			<span class="keyword">if</span>(x == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">			    a[i][j] = <span class="number">1</span>;</span><br><span class="line">                a[i<span class="number">-1</span>][j] = <span class="number">1</span>;</span><br><span class="line">                a[i][j<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">                a[i<span class="number">-1</span>][j<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; emmm &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">switch</span>(ch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'N'</span>: orz=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'S'</span>: orz=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'W'</span>: orz=<span class="number">3</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'E'</span>: orz=<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node first;</span><br><span class="line">    first.x = x1;</span><br><span class="line">    first.y = emmm;</span><br><span class="line">    first.t = orz;</span><br><span class="line">    first.time = <span class="number">0</span>;</span><br><span class="line">    q.push(first);</span><br><span class="line">    node u,d;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> turn = hh[i];</span><br><span class="line">            <span class="keyword">int</span> xx = Y[u.t]+i;</span><br><span class="line">            <span class="keyword">if</span>(xx == <span class="number">5</span>) xx = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(xx == <span class="number">6</span>) xx = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(xx == <span class="number">7</span>) xx = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(xx == <span class="number">8</span>) xx = <span class="number">4</span>;</span><br><span class="line">            xx = X[xx];</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">3</span>; j++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> Xx = u.x + fx[xx]*j;</span><br><span class="line">                <span class="keyword">int</span> Yy = u.y + fy[xx]*j;</span><br><span class="line">                <span class="keyword">if</span> ( Xx &gt;= n || Xx &lt;= <span class="number">0</span> || Yy &gt;= m || Yy &lt;= <span class="number">0</span> || (Xx == x1 &amp;&amp; Yy == emmm) || a[Xx][Yy] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>((u.time+turn+<span class="number">1</span>&lt;f[u.x+fx[xx]*j][u.y+fy[xx]*j] || f[u.x+fx[xx]*j][u.y+fy[xx]*j]==<span class="number">0</span>) &amp;&amp; a[u.x+fx[xx]*j][u.y+fy[xx]*j]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    d.x = u.x + fx[xx] * j;</span><br><span class="line">                    d.y = u.y + fy[xx] * j; </span><br><span class="line">                    d.t = xx;</span><br><span class="line">                    d.time = u.time + turn + <span class="number">1</span>;</span><br><span class="line">                    f[u.x + fx[xx] * j][u.y + fy[xx] * j] = d.time;</span><br><span class="line">                    q.push(d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[x2][y2] == <span class="number">0</span> &amp;&amp; (x2 != x1 || y2 != emmm)) <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;f[x2][y2]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><h4 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h4><p>众所周知，最短路分为单源最短路与多源最短路，具体分为Spfa，Dijjkstra，Floyd三种，下面我们来了解一下这三种算法</p>
<h5 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h5><p><img src="https://cdn.luogu.org/upload/pic/25108.png" alt="25108.png (800Ã599)"></p>
<p>本篇章以<a href="luogu.org/problem/3371">luogu P3371 【模板】单源最短路径（弱化版）</a>为例题</p>
<ol>
<li><p>功能</p>
<p>通常用于求含负权边的单源最短路径，以及判负权环,但容易被卡……</p>
</li>
<li><p>算法解释</p>
<p>详见百度百科，我颓了（逃</p>
</li>
<li><p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v,w,next;</span><br><span class="line">&#125;e[<span class="number">500005</span>];</span><br><span class="line"><span class="comment">//邻接表存图</span></span><br><span class="line"><span class="keyword">int</span> en,front[<span class="number">10005</span>],iq[<span class="number">10005</span>],d[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	en++;<span class="comment">//加边</span></span><br><span class="line">	e[en].v=v;e[en].w=w;e[en].next=front[u];front[u]=en;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="built_in">memset</span>(iq,<span class="number">0</span>,<span class="keyword">sizeof</span>(iq));<span class="comment">//重置数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d[i]=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;<span class="comment">//赋初值</span></span><br><span class="line">	&#125;</span><br><span class="line">	d[s]=<span class="number">0</span>,iq[s]=<span class="number">1</span>;<span class="comment">//将起点的值赋为0</span></span><br><span class="line">	q.push(s);<span class="comment">//加入队列</span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		iq[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=front[u];i&gt;=<span class="number">0</span>;i=e[i].next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v=e[i].v,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(d[v]&gt;d[u]+w)</span><br><span class="line">			&#123;<span class="comment">//松弛操作</span></span><br><span class="line">				d[v]=d[u]+w;</span><br><span class="line">				<span class="keyword">if</span>(!iq[v])</span><br><span class="line">				&#123;<span class="comment">//在队列的点就不加了</span></span><br><span class="line">					iq[v]=<span class="number">1</span>;</span><br><span class="line">					q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(front,<span class="number">-1</span>,<span class="keyword">sizeof</span>(front));</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		addedge(u,v,w);</span><br><span class="line">	&#125;<span class="comment">//输入加边</span></span><br><span class="line">	spfa();<span class="comment">//最短路</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(s==i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(d[i]==<span class="number">1073741824</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"2147483647"</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;d[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;<span class="comment">//输出</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h5><p>转自<a href="https://www.cnblogs.com/little-sun0331/p/9484730.html" target="_blank" rel="noopener">https://www.cnblogs.com/little-sun0331/p/9484730.html</a></p>
<p>本篇章以<a href="luogu.org/problem/4779">luogu P4779 【模板】单源最短路（标准版）</a>为例 </p>
<ol>
<li><p>前言</p>
<p>SPFA算法由于它上限 O(NM) = O(VE)的时间复杂度,被卡掉的几率很大.在算法竞赛中,我们需要一个更稳定的算法:dijkstra.</p>
</li>
<li><p>什么是dijkstra?</p>
</li>
</ol>
<ul>
<li>dijkstra是一种单源最短路径算法,时间复杂度上限为O(n^2)<em>O</em>(<em>n</em>2)(朴素),在实际应用中较为稳定;;加上堆优化之后更是具有O((n+m)\log_{2}n)<em>O</em>((<em>n</em>+<em>m</em>)log2<em>n</em>)的时间复杂度,在稠密图中有不俗的表现.</li>
</ul>
<ol start="3">
<li>dijkstra的原理/流程?</li>
</ol>
<ul>
<li>dijkstra本质上的思想是贪心,它只适用于不含负权边的图.</li>
<li>我们把点分成两类,一类是已经确定最短路径的点,称为”白点”,另一类是未确定最短路径的点,称为”蓝点”</li>
<li>dijkstra的流程如下::</li>
<li>1.1. 初始化dis[start] = 0,dis[start]=0,其余节点的dis值为无穷大.</li>
<li>2.2. 找一个dis值最小的蓝点x,把节点x变成白点.</li>
<li>3.3. 遍历x<em>x</em>的所有出边(x,y,z),(<em>x</em>,<em>y</em>,<em>z</em>),若dis[y] &gt; dis[x] + z,则令dis[y] = dis[x] + z</li>
<li>4.4. 重复2,32,3两步,直到所有点都成为白点..</li>
<li>时间复杂度为O(n^2)</li>
</ul>
<ol start="4">
<li>dijkstra为什么是正确的</li>
</ol>
<ul>
<li>当所有边长都是非负数的时候,全局最小值不可能再被其他节点更新.所以在第22步中找出的蓝点x<em>x</em>必然满足:dis[x]:<em>d<strong>i</strong>s</em>[<em>x</em>]已经是起点到x<em>x</em>的最短路径..我们不断选择全局最小值进行标记和拓展,最终可以得到起点到每个节点的最短路径的长度</li>
</ul>
<ol start="5">
<li>图解</li>
</ol>
<ul>
<li>(令start = 1)</li>
<li>开始时我们把dis[start]初始化为00,其余点初始化为inf<img src="https://i.loli.net/2018/07/25/5b583277e47e9.png" alt="初始化"></li>
<li>第一轮循环找到dis值最小的点1,将1变成白点,对所有与1相连的蓝点的dis值进行修改,使得dis[2]=2,dis[3]=4,dis[4]=7<img src="https://i.loli.net/2018/07/25/5b58347b9a37b.png" alt="1"></li>
<li>第二轮循环找到dis值最小的点2,将2变成白点,对所有与2相连的蓝点的dis值进行修改,使得dis[3]=3,dis[5]=4<img src="https://i.loli.net/2018/07/25/5b586fa8de335.png" alt="2"></li>
<li>第三轮循环找到dis值最小的点3,将3变成白点,对所有与2相连的蓝点的dis值进行修改,使得dis[4]=4<img src="https://i.loli.net/2018/07/25/5b58703e8d0d6.png" alt="3"></li>
<li>接下来两轮循环分别将4,5设为白点,算法结束,求出所有点的最短路径</li>
<li>时间复杂度O(n^2)*</li>
</ul>
<ol start="6">
<li>为什么dijkstra不能处理有负权边的情况?</li>
</ol>
<ul>
<li>我们来看下面这张图 <img src="https://i.loli.net/2018/07/25/5b58724845b8d.png" alt="4"></li>
<li>22到33的边权为-4−4,显然从11到33的最短路径为-2−2 (1-&gt;2-&gt;3).(1−&gt;2−&gt;3).但在循环开始时程序会找到当前dis值最小的点33,并标记它为白点.</li>
<li>这时的dis[3]=1,<em>d<strong>i</strong>s</em>[3]=1,然而11并不是起点到33的最短路径.因为33已经被标为白点,所以dis[3]<em>d<strong>i</strong>s</em>[3]不会再被修改了.我们在边权存在负数的情况下得到了错误的答案.</li>
</ul>
<ol start="7">
<li>dijkstra的堆优化?<ul>
<li>观察dijkstra的流程,发现步骤22可以优化</li>
<li>怎么优化呢?</li>
<li><del>我会zkw线段树!我会斐波那契堆!</del></li>
<li>我会堆!</li>
<li>我们可以用堆对dis数组进行维护,用O(\log_{2}n)的时间取出堆顶元素并删除,用O(log2n遍历每条边,总复杂度O<em>((*n</em>+<em>m</em>)log2*n)</li>
</ul>
</li>
<li>范例代码:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN = <span class="number">100010</span>, MaxM = <span class="number">500010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, dis, next;</span><br><span class="line">&#125;;</span><br><span class="line">edge e[MaxM];</span><br><span class="line"><span class="keyword">int</span> head[MaxN], dis[MaxN], cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[MaxN];</span><br><span class="line"><span class="keyword">int</span> n, m, s;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">( <span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    e[cnt].dis = d;</span><br><span class="line">    e[cnt].to = v;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dis;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;( <span class="keyword">const</span> node &amp;x )<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis &lt; dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.push( ( node )&#123;<span class="number">0</span>, s&#125; );</span><br><span class="line">    <span class="keyword">while</span>( !q.empty() )</span><br><span class="line">    &#123;</span><br><span class="line">        node tmp = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> x = tmp.pos, d = tmp.dis;</span><br><span class="line">        <span class="keyword">if</span>( vis[x] )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = head[x]; i; i = e[i].next )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y = e[i].to;</span><br><span class="line">            <span class="keyword">if</span>( dis[y] &gt; dis[x] + e[i].dis )</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y] = dis[x] + e[i].dis;</span><br><span class="line">                <span class="keyword">if</span>( !vis[y] )</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push( ( node )&#123;dis[y], y&#125; );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>( <span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;s );</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)dis[i] = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> u, v, d;</span><br><span class="line">        <span class="built_in">scanf</span>( <span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;d );</span><br><span class="line">        add_edge( u, v, d );</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ )</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">"%d "</span>, dis[i] );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h5><p>本篇章以<a href="http://codeforces.com/contest/295/problem/B" target="_blank" rel="noopener">CF295B</a>为例</p>
<ol>
<li>功能</li>
</ol>
<p>​        求多源最短路，从任意一个点到任意另一个点的最短路</p>
<ol start="2">
<li>算法解释</li>
</ol>
<p>​        Floyd的本质是DP（写后边了），核心是对一条边的松弛操作</p>
<p>​        f [i] [j] = min(f [i] [k]+f [k] [j])——松弛操作</p>
<p>​        就求出最短路了emmmmmm~</p>
<ol start="3">
<li><p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;//实在没啥好说的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,ask[<span class="number">502</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">502</span>][<span class="number">502</span>],ans[<span class="number">502</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">502</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">	        <span class="built_in">cin</span> &gt;&gt; f[i][j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; ask[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> l=ask[i];</span><br><span class="line">		vis[l]=<span class="literal">true</span>;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">	        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)</span><br><span class="line">	        &#123;<span class="comment">//松弛操作</span></span><br><span class="line">	        	f[j][k] = min(f[j][k],f[j][l] + f[l][k]);</span><br><span class="line">	            <span class="keyword">if</span>(vis[j] &amp;&amp; vis[k]) ans[l] += f[j][k];</span><br><span class="line">			&#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">cout</span> &lt;&lt; ans[ask[i]] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>最小生成树有两种算法——Prim和Kruskal</p>
<h5 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h5><p>本篇章以<a href="luogu.org/problem/P1546">luogu P1546 最短网络 Agri-Net</a>为例题</p>
<ol>
<li><p>功能</p>
<p>求出最小生成树，在稠密图中效果拔群！</p>
</li>
<li><p>算法解释</p>
<p>图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小。</p>
<p>Prim的思想是将任意节点作为根，再找出与之相邻的所有边（用一遍循环即可），再将新节点更新并以此节点作为根继续搜</p>
<p>图示——</p>
<p><img src="https://cdn.luogu.org/upload/pic/28090.png" alt=""></p>
</li>
<li><p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设已经确定属于最小生成树的节点集合为T，剩余节点集合为S</span></span><br><span class="line"><span class="comment">//Prim算法找到两个端点分别属于S与T的权值最小的边，然后x从S中删除，加到T中，ans累加</span></span><br><span class="line"><span class="comment">//若x属于S，则d[x]表示节点x与集合T中的节点之间权值最小的边的权值。</span></span><br><span class="line"><span class="comment">//若x属于T，则d[x]表示节点x加入T时选出的最小的边的权值。</span></span><br><span class="line"><span class="comment">//反正不看上面我不知道qwq</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">3005</span>][<span class="number">3005</span>],d[<span class="number">3005</span>],ans;</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">3005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span> (d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="built_in">memset</span> (visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">	d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++ ) <span class="keyword">if</span> (!visit[j] &amp;&amp; (x == <span class="number">0</span> || d[j] &lt; d[x ])) x = j;</span><br><span class="line">		visit[x] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++ ) <span class="keyword">if</span> (!visit[j]) d[j] = min (d[j],a[x][j]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ )</span><br><span class="line">	    <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=n; j++ )</span><br><span class="line">	    &#123;</span><br><span class="line">	    	<span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	prim();</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++ ) ans +=d[i];</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h5><p>本篇章以<a href="luogu.org/problem/P3366">luogu P3366 【模板】 最小生成树</a>为例题</p>
<ol>
<li><p>功能</p>
<p>求出最小生成树，在稀疏图中效果拔群！</p>
</li>
<li><p>算法解释</p>
<p>先构造一个只含 n 个顶点、而边集为空的子图，把子图中各个顶点看成各棵树上的根结点，之后，从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，即把两棵树合成一棵树，反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直到森林中只有一棵树，也即子图中含有 n-1 条边为止。过程——</p>
<ol>
<li>新建图G，G中拥有原图中相同的节点，但没有边；</li>
<li>将原图中所有的边按权值从小到大排序；</li>
<li>从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中；</li>
<li>重复3，直至图G中所有的节点都在同一个连通分量中。</li>
</ol>
<p>本质上是运用了并查集的思想。</p>
<p>图示——</p>
<p><img src="https://cdn.luogu.org/upload/pic/28091.png" alt=""></p>
</li>
<li><p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;a[<span class="number">500005</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(node i,node j)</span> </span>&#123; <span class="keyword">return</span> i.z &lt; j.z; &#125;</span><br><span class="line"><span class="keyword">int</span> n,m,ans,fa[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//找祖先</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x] = find (fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++ ) <span class="built_in">cin</span> &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].z;</span><br><span class="line">	sort (a+<span class="number">1</span>,a+<span class="number">1</span>+m,cmp);<span class="comment">//按边权排序</span></span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ ) fa[i] = i;</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++ ) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> xx = find (a[i].x),yy = find(a[i].y);</span><br><span class="line">		<span class="keyword">if</span> (xx == yy) <span class="keyword">continue</span>;<span class="comment">//祖先一样，已有边</span></span><br><span class="line">		fa[xx] = yy;</span><br><span class="line">		ans +=a[i].z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h4><p>转自<a href="https://www.cnblogs.com/zwfymqz/p/8581995.html" target="_blank" rel="noopener">https://www.cnblogs.com/zwfymqz/p/8581995.html</a></p>
<p>本篇章以<a href="luogu.org/problem/P3865">luogu P3865 【模板】ST表</a>为例题</p>
<ol>
<li><p>功能    </p>
<p>ST表是解决RMQ问题的一种强有力的工具，它可以做到O(nlogn)预处理，O(1)查询最值</p>
</li>
<li><p>算法解释</p>
<ol>
<li><p>ST表是利用的是<strong>倍增</strong>的思想</p>
<p>拿最大值来说，我们用b[i] [j]表示，从i位置开始的2j个数中的最大值，例如Max[i] [1]表示的是i位置和i+1位置中两个数的最大值，那么转移的时候我们可以把当前区间拆成两个区间并分别取最大值（注意这里的编号是从1开始的）</p>
<p> <img src="https://i.loli.net/2019/08/26/5ZIFzj61PsmCHXu.png" alt=""></p>
<p>查询的时候也比较简单，我们计算出log2(区间长度)，然后对于左端点和右端点分别进行查询，这样可以保证一定可以覆盖查询的区间。</p>
<p><img src="https://i.loli.net/2019/08/26/vZ736TwSGcEbNtF.png" alt=""></p>
<p>为什么从右端点开始查的时候左端点是r−2^k+1？</p>
<p>实际很简单，因为我们需要找到一个点x，使得x+2^k−1=r，这样的话就可以得到x=r−2^k+1。</p>
</li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,b[MAXN][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ST</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = log2(r-l+<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">return</span> max(b[l][k],b[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">    <span class="comment">//把拆出来的区间分别取最值 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,b[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">21</span>; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i+(<span class="number">1</span> &lt;&lt; j)<span class="number">-1</span> &lt;= N;i++) </span><br><span class="line">            b[i][j] = max(b[i][j<span class="number">-1</span>],b[i + (<span class="number">1</span> &lt;&lt; (j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">    <span class="comment">//注意这里要控制边界,如果看不懂边界的话建议好好看看图 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,l,r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ST(l,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>本篇章以<a href="luogu.org/problem/P3367">洛谷 P3367 【模板】并查集</a>为例题</p>
<ol>
<li><p>功能</p>
<p>并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。并查集是一种树型的数据结构，用于处理一些不相交<a href="https://baike.baidu.com/item/集合/2908117" target="_blank" rel="noopener">集合</a>（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。</p>
</li>
<li><p>算法解释</p>
<p>利用递归，进行处理，找到每个节点的最远祖先。</p>
<p>例如，初始化后，我们是这样<img src="https://i.loli.net/2019/08/23/1jY6ef2mBqQD8NL.png" alt="">)通过输入，我们将图建成了这样<img src="https://i.loli.net/2019/08/23/7x932FdlyDpMSRW.png" alt=""></p>
<p>而通过并查集，我们将图形改成了这样<img src="https://i.loli.net/2019/08/23/afMQgrGOyXpE2DC.png" alt=""></p>
<p>这便是并查集的作用</p>
</li>
<li><p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,f[<span class="number">10005</span>],x,y,z;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( f[k] == k ) &#123;<span class="keyword">return</span> k;&#125;</span><br><span class="line">	<span class="keyword">return</span> f[k] = find (f[k]);</span><br><span class="line">&#125;<span class="comment">//递归查找祖先</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ ) f[i] = i;<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; z &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">if</span> ( z == <span class="number">1</span> ) f[find (x)] = find (y);<span class="comment">//合并操作</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> ( find(x) == find(y) ) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Y"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"N"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><p>本篇章以<a href="luogu.org/problem/P3374">洛谷 P3374 【模板】树状数组1</a>为例题</p>
<ol>
<li><p>功能</p>
<p>树状数组(Binary Indexed Tree(B.I.T))是一个查询和修改复杂度都为log(n)的数据结构。主要用于查询任意两位之间的所有元素之和，但是每次只能修改一个元素的值；经过简单修改可以在log(n)的复杂度下进行范围修改，但是这时只能查询其中一个元素的值(如果加入多个辅助数组则可以实现区间修改与区间查询)，树状数组和线段树很像，但能用树状数组解决的问题，基本上都能用线段树解决，而线段树能解决的树状数组不一定能解决。相比较而言，树状数组效率要高很多</p>
</li>
<li><p>算法解释</p>
<p>树状数组是基于前缀和和差分的，他的每个节点如下图所示 </p>
<p><img src="http://p0.so.qhimgs1.com/bdr/_240_/t01b3cd94b11782f024.png" alt=""></p>
<p>那我们怎么知道这个数组里存的是什么呢？接下来就是树状数组的一个关键操作——lowbit。因为C数组里存的东西和它的二进制有着不可分割的关系，C数组的下标i如果以x个0结尾，它就存了A[i-2^x+1] A[i]的数据，而lowbit可以快速的求出2^x</p>
<p><em>lowbit</em>   =  <em>i</em>  and  −<em>i</em></p>
</li>
<li><p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,tree[<span class="number">500005</span>],a,b,c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span> <span class="params">(<span class="keyword">int</span> k)</span> </span>&#123; <span class="keyword">return</span> k &amp; -k; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> ( x &lt;= n )</span><br><span class="line">	&#123;</span><br><span class="line">		tree[x] += y;</span><br><span class="line">		x += lowbit(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//求和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( x != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        ans += tree[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ ) <span class="built_in">cin</span> &gt;&gt; a,add(i,a);</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		<span class="keyword">if</span> ( a == <span class="number">1</span> ) add(b,c);</span><br><span class="line">		<span class="keyword">if</span> ( a == <span class="number">2</span> ) <span class="built_in">cout</span> &lt;&lt; sum(c) - sum(b<span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><p>本篇章以<a href="luogu.org/problem/P3373">洛谷 P3373 【模板】线段树2</a>为例题</p>
<ol>
<li><p>功能 </p>
<p>线段树之所以称为“树”，是因为其具有树的结构特性。线段树由于本身是专门用来处理区间问题的。</p>
</li>
<li><p>算法解释</p>
<p>定义</p>
<ul>
<li>线段树是一个完全二叉树</li>
<li>它在各个节点保存一条线段（数组中的一段子数组）</li>
<li>每个单元区间对应线段树中的一个叶结点</li>
<li>性质：父亲的区间是[l,r],(m=(l+r)/2)左儿子的区间是[l,m]，右儿子的区间是[m+1,r]，线段树需要的空间为数组大小的四倍</li>
</ul>
<p>对于每一个子节点而言，都表示整个序列中的一段子区间；对于每个叶子节点而言，都表示序列中的单个元素信息；子节点不断向自己的父亲节点传递信息，而父节点存储的信息则是他的每一个子节点信息的整合。如图</p>
<p><img src="http://p0.so.qhimgs1.com/bdr/_240_/t016b0d2e51e372bef0.png" alt=""></p>
<ul>
<li><h3 id="lazytag"><a href="#lazytag" class="headerlink" title="lazytag"></a>lazytag</h3><p>标记下传的本质也和前面操作一样，如果操作一段区间，那就只要记录在这段区间公共祖先节点上（单点其实也是区间，只不过长度为1罢了）。当我们需要查询子节点的信息的时候我们再进行更新，也就是当我们不需要查询的时候，就下传标记，要用的时候就使用标记，再将使用的标记清零，我们采用上述方式，就只需要在每次操作时下传一次标记即可，大大节省了时间。<br>这种不仅简单粗暴，还剩时间的方法，被称为————懒标记（lazytag）。但是在访问任何一个节点时，都需要保证该节点的祖先标记都被清空，这样才能保证正确性</p>
</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(k) (k)&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(k) (k)&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll  long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll n,m,w,x,y,z,p,a[<span class="number">500005</span>],sum[<span class="number">500005</span>*<span class="number">4</span>],add[<span class="number">500005</span>*<span class="number">4</span>],And[<span class="number">500005</span>*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(ll k,ll l,ll r)</span><span class="comment">//建树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	And[k] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> ( l == r ) &#123; sum[k] = a[l] ; <span class="keyword">return</span> ; &#125;<span class="comment">//区间和</span></span><br><span class="line">	ll mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build ( ls(k) , l , mid );<span class="comment">//遍历左儿子</span></span><br><span class="line">    build ( rs(k) , mid+<span class="number">1</span> , r );<span class="comment">//遍历右儿子</span></span><br><span class="line">    sum[k] = (sum[ls(k)] + sum[rs(k)]) % p;<span class="comment">//区间和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ad</span> <span class="params">(ll k,ll l,ll r,ll x,ll y)</span><span class="comment">//laytag</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add[k] = ( add[k]*x + y ) % p;</span><br><span class="line">	sum[k] = ( sum[k]*x + y * ( r - l + <span class="number">1</span> )) % p;</span><br><span class="line">	And[k] = ( And[k] * x ) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span> <span class="params">(ll k,ll l,ll r,ll mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ad (ls(k),l,mid,And[k],add[k]);</span><br><span class="line">    ad (rs(k),mid+<span class="number">1</span>,r,And[k],add[k]);</span><br><span class="line">    add[k] = <span class="number">0</span>;</span><br><span class="line">    And[k] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AnD</span> <span class="params">(ll k,ll l,ll r,ll x,ll y,ll z)</span><span class="comment">//乘</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l&gt;=x&amp;&amp;r&lt;=y) &#123; ad(k,l,r,z,<span class="number">0</span>); <span class="keyword">return</span>; &#125;<span class="comment">//如果包括遍历区间，就直接来</span></span><br><span class="line">	ll mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    pushdown(k,l,r,mid);<span class="comment">//标记下传</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) AnD(ls(k),l,mid,x,y,z);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) AnD(rs(k),mid+<span class="number">1</span>,r,x,y,z);</span><br><span class="line">    sum[k] = ( sum[ls(k)] + sum[rs(k)] ) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span> <span class="params">(ll k,ll l,ll r,ll x,ll y,ll z)</span><span class="comment">//加</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;=x&amp;&amp;r&lt;=y) &#123; ad(k,l,r,<span class="number">1</span>,z); <span class="keyword">return</span>; &#125;<span class="comment">///如果包括遍历区间，就直接加</span></span><br><span class="line">    ll mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    pushdown(k,l,r,mid);<span class="comment">//标记下传</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) Add(ls(k),l,mid,x,y,z);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; y) Add(rs(k),mid+<span class="number">1</span>,r,x,y,z);</span><br><span class="line">    sum[k] = ( sum[ls(k)] + sum[rs(k)] ) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span> <span class="params">(ll k,ll l,ll r,ll x,ll y)</span><span class="comment">//查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( l &gt;= x &amp;&amp; r &lt;= y ) <span class="keyword">return</span> sum[k];</span><br><span class="line">    ll mid = (l+r) &gt;&gt; <span class="number">1</span>,ans = <span class="number">0</span>;</span><br><span class="line">    pushdown(k,l,r,mid);<span class="comment">//标记下传</span></span><br><span class="line">    <span class="keyword">if</span> ( x &lt;= mid ) ans = check (ls(k),l,mid,x,y);</span><br><span class="line">    <span class="keyword">if</span> ( mid &lt; y ) ans += check (rs(k),mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n  &gt;&gt; p;</span><br><span class="line">	<span class="keyword">for</span> ( ll i = <span class="number">1</span>; i &lt;= n; i++ ) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; w &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">if</span> ( w == <span class="number">1</span> ) <span class="built_in">cin</span> &gt;&gt; z , AnD (<span class="number">1</span>,<span class="number">1</span>,n,x,y,z);</span><br><span class="line">		<span class="keyword">if</span> ( w == <span class="number">2</span> ) <span class="built_in">cin</span> &gt;&gt; z , Add (<span class="number">1</span>,<span class="number">1</span>,n,x,y,z);</span><br><span class="line">		<span class="keyword">if</span> ( w == <span class="number">3</span> ) <span class="built_in">cout</span> &lt;&lt; check (<span class="number">1</span>,<span class="number">1</span>,n,x,y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h3><h4 id="KMP字符串匹配"><a href="#KMP字符串匹配" class="headerlink" title="KMP字符串匹配"></a>KMP字符串匹配</h4><p>本篇章以<a href="luogu.org/problem/P3375">洛谷 P3375 【模板】KMP字符串匹配</a>为例题</p>
<ol>
<li><p>功能</p>
<p>RT，字符串匹配，寻找相同的字符串</p>
</li>
<li><p>算法解释</p>
<p>设主串（下文中我们称作T）为：a b a c a a b a c a b a c a b a a b b</p>
<p>模式串（下文中我们称作W）为：a b a c a b</p>
<p>用暴力算法匹配字符串过程中，我们会把T[0] 跟 W[0] 匹配，如果相同则匹配下一个字符，直到出现不相同的情况，此时我们会丢弃前面的匹配信息，然后把T[1] 跟 W[0]匹配，循环进行，直到主串结束，或者出现匹配成功的情况。这种丢弃前面的匹配信息的方法，极大地降低了匹配效率。</p>
<p>而在KMP算法中，对于每一个模式串我们会事先计算出模式串的内部匹配信息，在匹配失败时最大的移动模式串，以减少匹配次数。</p>
<p>比如，在简单的一次匹配失败后，我们会想将模式串尽量的右移和主串进行匹配。右移的距离在KMP算法中是如此计算的：在已经匹配的模式串子串中，找出最长的相同的前缀和后缀后缀)，然后移动使它们重叠。</p>
<p>在第一次匹配过程中</p>
<p>T: a b a c a a b c a b a c a b a a b b</p>
<p>W: a b a c a b</p>
<p>在T[5]与W[5]出现了不匹配，而T[0]<del>T[4]是匹配的，其中T[0]</del>T[4]就是上文中说的<strong>已经匹配的模式串子串，</strong>移动找出<strong>最长的相同的前缀和后缀并使他们重叠：</strong></p>
<p>T: a b a c a b a c a b a c a b a a b b</p>
<p>W: a b a c a b</p>
<p>然后在从上次匹配失败的地方进行匹配，这样就减少了匹配次数，增加了效率。</p>
<p>然而，如果每次都要计算<strong>最长的相同的前缀</strong>反而会浪费时间，所以对于模式串来说，我们会提前计算出每个匹配失败的位置应该移动的距离，花费的时间就成了常数时间</p>
</li>
<li><p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a1,b1,j,next[<span class="number">1000005</span>]; <span class="comment">//next 数组（KMP必备</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">1000005</span>],b[<span class="number">1000005</span>];<span class="comment">//字符数组（用字符串也行）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a+<span class="number">1</span> &gt;&gt; b+<span class="number">1</span>;<span class="comment">//从a[1]开始输入</span></span><br><span class="line">    a1 = <span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line">    b1 = <span class="built_in">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= b1;i++)</span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; b[i] != b[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line">        <span class="comment">//如果失配 ，那么就不断向回跳，直到可以继续匹配 </span></span><br><span class="line">        <span class="keyword">if</span>(b[j+<span class="number">1</span>] == b[i]) j++;</span><br><span class="line">        <span class="comment">//如果匹配成功，那么对应的模式串位置++ </span></span><br><span class="line">        next[i] = j;</span><br><span class="line">        <span class="comment">//继续匹配 </span></span><br><span class="line">    &#125;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算next 数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= a1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; b[j+<span class="number">1</span>] != a[i]) j = next[j];</span><br><span class="line">        <span class="comment">//如果回跳到第一个字符就不用再回跳了</span></span><br><span class="line">        <span class="keyword">if</span>(b[j+<span class="number">1</span>] == a[i]) j++;</span><br><span class="line">        <span class="comment">//通过自己匹配自己来得出每一个点的kmp值 </span></span><br><span class="line">        <span class="keyword">if</span>(j == b1)</span><br><span class="line">        <span class="comment">//i+1失配后应该如何跳 </span></span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="built_in">cout</span> &lt;&lt; i-b1+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= b1;i++)<span class="built_in">cout</span> &lt;&lt; next[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="comment">//输出next数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="AC自动机（好吧，鸽了）"><a href="#AC自动机（好吧，鸽了）" class="headerlink" title="AC自动机（好吧，鸽了）"></a>AC自动机（好吧，鸽了）</h4><p>咕咕咕（显露本质）我不会了qaq</p>
<h3 id="动态规划（DP）"><a href="#动态规划（DP）" class="headerlink" title="动态规划（DP）"></a>动态规划（DP）</h3><h4 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h4><p>本篇章以<a href="luogu.org/problem/P2704">luogu P2704 炮兵阵地</a>为例题</p>
<ol>
<li><p>功能</p>
<p>是状态压缩 + dp，我们在动态规划时，需要把一个“集合”结构记录在状态中，就可以考虑采用压缩的方式转化为一个整数进行存储。</p>
</li>
<li><p>算法解释</p>
<p>在任意时刻，已经求出最优解的状态与尚未求出最优解的状态在各维度上的分界点组成了DP的轮廓，对于某些问题，我们需要在动态规划的状态中记录一个集合，保存这个轮廓的详细信息，以便进行状态转移。若集合大小不超过N，集合中每个元素都是小于K的自然数，则我们可以把这个集合看做一个N位K进制数，以一个[0，k^N-1]之间的十进制整数的形式作为DP状态的一维</p>
</li>
<li><p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt,f[<span class="number">1</span>&lt;&lt;<span class="number">8</span>],num[<span class="number">1</span>&lt;&lt;<span class="number">8</span>],ans;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>],dp[<span class="number">105</span>][<span class="number">1</span>&lt;&lt;<span class="number">8</span>][<span class="number">1</span>&lt;&lt;<span class="number">8</span>];</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ )</span><br><span class="line">	    <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++ ) </span><br><span class="line">	    &#123;</span><br><span class="line">	    	<span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">	    	<span class="keyword">if</span> (ch == <span class="string">'H'</span>) a[i] += <span class="number">1</span> &lt;&lt; (j<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//把每行“不可选”状态压缩起来方便实用</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;m); i++ )</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; (i&lt;&lt;<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; (i&lt;&lt;<span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; (i&gt;&gt;<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; (i&gt;&gt;<span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//左右不能有Italy 炮</span></span><br><span class="line">        cnt++;</span><br><span class="line">        f[cnt] = i;</span><br><span class="line">        <span class="keyword">int</span> now = i;</span><br><span class="line">        <span class="keyword">while</span>(now&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="comment">//求取每个状态的贡献</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(now &amp; <span class="number">1</span>) num[cnt]++;</span><br><span class="line">            now &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++  )<span class="comment">//处理第一排</span></span><br><span class="line">        <span class="keyword">if</span> ((f[i] &amp; a[<span class="number">1</span>]) == <span class="number">0</span>)<span class="comment">//不能与地形冲突</span></span><br><span class="line">		&#123;</span><br><span class="line">            dp[<span class="number">1</span>][i][<span class="number">0</span>] = num[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++ )<span class="comment">//处理第二排</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++ )</span><br><span class="line">            <span class="comment">//判断是否冲突</span></span><br><span class="line">            <span class="keyword">if</span> ( !(f[i] &amp; f[j]) &amp;&amp; !(f[i] &amp; a[<span class="number">2</span>]) &amp;&amp; !(f[j] &amp; a[<span class="number">1</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                dp[<span class="number">2</span>][i][j] = num[j] + num[i];</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++ )<span class="comment">//枚举行 </span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++ )<span class="comment">//本行的状态 </span></span><br><span class="line">            <span class="keyword">if</span> (!(f[j] &amp; a[i]))<span class="comment">//不在山丘上时 </span></span><br><span class="line">                <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= cnt; k++ )<span class="comment">//枚举上一行状态 </span></span><br><span class="line">                    <span class="keyword">if</span> (!(f[k] &amp; a[i<span class="number">-1</span>]) &amp;&amp; !(f[k] &amp; f[j]))<span class="comment">//不在山上，且不与本行冲突 </span></span><br><span class="line">                        <span class="keyword">for</span> ( <span class="keyword">int</span> l = <span class="number">1</span>;  l&lt;= cnt; l++ )<span class="comment">//看上两行状态 </span></span><br><span class="line">                            <span class="keyword">if</span> ( !(f[l] &amp; a[i<span class="number">-2</span>]) &amp;&amp; !(f[l] &amp; f[k]) &amp;&amp; !(f[l] &amp; f[j]))</span><br><span class="line">                            <span class="comment">//不在山上，不冲突时 </span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">//动态转移，ans取最大 </span></span><br><span class="line">                                dp[i][j][k] = max (dp[i][j][k],dp[i<span class="number">-1</span>][k][l]+num[j]);</span><br><span class="line">                                ans = max (ans,dp[i][j][k]);</span><br><span class="line">                            &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h4><p>本篇章以<a href="https://www.luogu.org/problemnew/show/P2015" target="_blank" rel="noopener">洛谷 P2015 【模板】二叉苹果树</a>为例题</p>
<ol>
<li><p>功能</p>
<p>AKNOIP（滑稽保命</p>
</li>
<li><p>算法解释</p>
<p>树上的DP（我越来越sb了。。。</p>
<p>所谓的树形DP，只不过是将一般DP的线性转移，变成了在树上进行转移，本质并无差别</p>
</li>
<li><p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,cnt,head[<span class="number">105</span>],emmm[<span class="number">205</span>],dp[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span><span class="comment">//结构体存树</span></span><br><span class="line">	<span class="keyword">int</span> to,next,apple;</span><br><span class="line">&#125;e[<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maketree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span><span class="comment">//建树，无向图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].to = v , e[cnt].apple = w , e[cnt].next = head[u] , head[u] = cnt;</span><br><span class="line">    e[++cnt].to = u , e[cnt].apple = w , e[cnt].next = head[v] , head[v] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span><span class="comment">//进行DP</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = head[x]; i; i = e[i].next )</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>( v == fa ) <span class="keyword">continue</span>;</span><br><span class="line">        dfs (v, x);</span><br><span class="line">		emmm[x] += emmm[v] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = emmm[x]; j&gt;=<span class="number">0</span>; j--)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> k = min(emmm[v], j<span class="number">-1</span>); k &gt;= <span class="number">0</span>; k-- )</span><br><span class="line">			&#123;</span><br><span class="line">                dp[x][j] = max(dp[x][j], dp[x][j-k<span class="number">-1</span>] + dp[v][k] + e[i].apple);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> _u , _v , _w;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; _u &gt;&gt; _v &gt;&gt; _w;</span><br><span class="line">		maketree ( _u,_v,_w );</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dp[<span class="number">1</span>][q] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h3><p>我发现我都说不出数论的功能……名字就是功能……</p>
<h4 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h4><p>本篇章以<a href="https://www.luogu.org/problemnew/show/P3383" target="_blank" rel="noopener">洛谷 P3383 【模板】线性筛素数</a>为例题</p>
<ol>
<li><p>功能</p>
<p>线性筛素数……（雾</p>
</li>
<li><p>算法解释</p>
<p>好像没啥可说的……将1/2特判，剩下的对其sqrt(其)取模，膜开YES，膜不开NO。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,y;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ss</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">2</span>)&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">    <span class="comment">//1和2需要特判</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;y;</span><br><span class="line">		<span class="keyword">if</span>(ss(y))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><p>本篇章以<a href="luogu.org/problem/P1266">洛谷 P1266 【模板】快速幂||取余运算</a>为例题</p>
<ol>
<li><p>功能</p>
<p>快速求幂，就是个板子，快速幂的板子</p>
</li>
<li><p>算法解释</p>
<p>因为乘法符合结合律，所以……可以取余运算（啪！</p>
<p>快速幂利用的就是二进制 。我们可以把a^b中的b拆成二进制，该二进制数第i位的权值是2^(i-1)</p>
<p>11的二进制是10111011，11=2^{3}×1 + 2^{2}×0 + 2^{1}×1 + 2^{1}×111=23×1+22×0+21×1+21×1</p>
<p>因此，我们将a^{11}转化为算 a^{2^0+2^1+2^3}，原来算11次，现在算三次</p>
<p>有两个必要操作——&amp;1:取二进制的最末位,还可以判断奇偶；&gt;&gt;1:二进制去掉最后一位。</p>
<p>其实也很好理解，以b=11为例，b=&gt;1011,二进制从右向左算，顺序是 a^{2^0}×a^{2^1}×a^{2^3}，是从左向右的，我们不断的让c累乘即可。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> b,p,k,s,ans=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; b &gt;&gt; p &gt;&gt; k;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="string">"^"</span> &lt;&lt; p &lt;&lt; <span class="string">" mod "</span> &lt;&lt; k &lt;&lt; <span class="string">"="</span>;</span><br><span class="line">	<span class="keyword">while</span>(p &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(p % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	ans = ans * b % k;</span><br><span class="line">		&#125;</span><br><span class="line">        b = b * b % k;</span><br><span class="line">        p = p &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans % k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*好吧，这好像是取余运算</span></span><br><span class="line"><span class="comment">那来个快速幂？</span></span><br><span class="line"><span class="comment">正在学习中………………*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,b,k,c,ans=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; k;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">"^"</span> &lt;&lt; b &lt;&lt; <span class="string">" mod "</span> &lt;&lt; k &lt;&lt; <span class="string">"="</span>;</span><br><span class="line">    c = a;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span> == <span class="number">1</span>) ans = (ans * c) % k;</span><br><span class="line">        c = (c * c) % k;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans % k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h4><ol>
<li><p>功能</p>
<p>在矩阵中快速求幂（快哭了</p>
</li>
<li><p>算法解释</p>
<p>矩阵乘法满足结合律，但不满足交换律，计算规则是，第一个矩阵第一行的每个数字（2 和1），各自乘以第二个矩阵第一列对应位置的数字（1 和1），然后将乘积相加（ 2 x 1 + 1 x 1），得到结果矩阵左上角的那个值3。</p>
<p><img src="https://img-blog.csdn.net/20170816154142793?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU5MTQ1ODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
</li>
<li><p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其实就是套快速幂的板子qwq</span></span><br><span class="line"><span class="comment">//不看 long long 见祖宗</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,p;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> qaq[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">&#125;;</span><br><span class="line">node a,b,ans;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">node <span class="title">work</span><span class="params">(node x,node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">            c.qaq[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)</span><br><span class="line">                c.qaq[i][j] = (c.qaq[i][j] + (x.qaq[i][k] * y.qaq[k][j]) % mod) % mod;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">workout</span><span class="params">(node x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node sum = b;</span><br><span class="line">    <span class="keyword">while</span> (y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y % <span class="number">2</span> == <span class="number">1</span>) sum = work (sum,x);</span><br><span class="line">        x = work (x,x);</span><br><span class="line">		y /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a.qaq[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        b.qaq[i][i]=<span class="number">1</span>; </span><br><span class="line">	ans = workout (a,p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans.qaq[i][j] % mod &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h4><ol>
<li><p>功能</p>
<p>乘法逆元，一般用于求a/b mod p 的值（p 通常为质数），是解决模意义下分数数值的必要手段。</p>
</li>
<li><p>算法解释</p>
<p>若 a ∗ x ≡ 1 (mod b)，且a与b互质，那么我们就能定义: x 为 a 的逆元，记为a^{-1}，所以我们也可以称 x 为 a 在 mod b 意义下的倒数，</p>
<p>所以对于a/b (mod p) ，我们就可以求出 b 在 mod p 下的逆元，然后乘上 a ，再mod p，就是这个分数的值了。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3000010</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> inv[N],n,p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>; <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        inv[i] = (ll) (p-p/i)*inv[p%i]%p;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,inv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="欧几里得算法（辗转相除法）"><a href="#欧几里得算法（辗转相除法）" class="headerlink" title="欧几里得算法（辗转相除法）"></a>欧几里得算法（辗转相除法）</h4><ol>
<li>功能——咕咕咕</li>
</ol>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://pic1.zhimg.com/80/v2-de25f47ce1af774c75d9b0a60fb816fc_hd.jpg" alt=""></h4>
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/13/Hollow%20Knight%E6%9D%82%E8%AE%B0/" rel="next" title="Hollow Knight杂记">
                <i class="fa fa-chevron-left"></i> Hollow Knight杂记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/14/%E9%A2%98%E8%A7%A3%20P4961%20%E3%80%90%E5%B0%8F%E5%9F%8B%E4%B8%8E%E6%89%AB%E9%9B%B7%E3%80%91/" rel="prev" title="题解 P4961 【小埋与扫雷】">
                题解 P4961 【小埋与扫雷】 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.jpg"
                alt="Konnyaku_ljc"/>
            
              <p class="site-author-name" itemprop="name">Konnyaku_ljc</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/%20%7C%7C%20archive">
                
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础算法详解"><span class="nav-number">1.</span> <span class="nav-text">基础算法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-8-鸽了，以后每天都不鸽！（真香qwq）-逃"><span class="nav-number">1.0.0.0.1.</span> <span class="nav-text">2019&#x2F;8&#x2F;8 鸽了，以后每天都不鸽！（真香qwq）(逃</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-9-开始更新"><span class="nav-number">1.0.0.0.2.</span> <span class="nav-text">2019&#x2F;8&#x2F;9 开始更新</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-9-加入ST表"><span class="nav-number">1.0.0.0.3.</span> <span class="nav-text">2019&#x2F;8&#x2F;9 加入ST表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-9-加入深度优先搜索（DFS）"><span class="nav-number">1.0.0.0.4.</span> <span class="nav-text">2019&#x2F;8&#x2F;9 加入深度优先搜索（DFS）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-9-加入SPFA（虽然它死了……）"><span class="nav-number">1.0.0.0.5.</span> <span class="nav-text">2019&#x2F;8&#x2F;9 加入SPFA（虽然它死了……）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-10-加入dijkstra"><span class="nav-number">1.0.0.0.6.</span> <span class="nav-text">2019&#x2F;8&#x2F;10 加入dijkstra</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-11-加入Floyd"><span class="nav-number">1.0.0.0.7.</span> <span class="nav-text">2019&#x2F;8&#x2F;11 加入Floyd</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-13-加入KMP"><span class="nav-number">1.0.0.0.8.</span> <span class="nav-text">2019&#x2F;8&#x2F;13 加入KMP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-13-加入自动AC机"><span class="nav-number">1.0.0.0.9.</span> <span class="nav-text">2019&#x2F;8&#x2F;13 加入自动AC机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-23-加入并查集"><span class="nav-number">1.0.0.0.10.</span> <span class="nav-text">2019&#x2F;8&#x2F;23 加入并查集</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-24-加入广度优先搜索（BFS）"><span class="nav-number">1.0.0.0.11.</span> <span class="nav-text">2019&#x2F;8&#x2F;24 加入广度优先搜索（BFS）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-24-加入状压DP"><span class="nav-number">1.0.0.0.12.</span> <span class="nav-text">2019&#x2F;8&#x2F;24 加入状压DP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-24-加入矩阵快速幂"><span class="nav-number">1.0.0.0.13.</span> <span class="nav-text">2019&#x2F;8&#x2F;24 加入矩阵快速幂</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-25-加入乘法逆元"><span class="nav-number">1.0.0.0.14.</span> <span class="nav-text">2019&#x2F;8&#x2F;25 加入乘法逆元</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-26-加入树状数组"><span class="nav-number">1.0.0.0.15.</span> <span class="nav-text">2019&#x2F;8&#x2F;26 加入树状数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-26-加入线段树"><span class="nav-number">1.0.0.0.16.</span> <span class="nav-text">2019&#x2F;8&#x2F;26 加入线段树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-26-加入树形DP"><span class="nav-number">1.0.0.0.17.</span> <span class="nav-text">2019&#x2F;8&#x2F;26 加入树形DP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-29-加入Prim"><span class="nav-number">1.0.0.0.18.</span> <span class="nav-text">2019&#x2F;8&#x2F;29 加入Prim</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2019-8-29-加入Kruskal"><span class="nav-number">1.0.0.0.19.</span> <span class="nav-text">2019&#x2F;8&#x2F;29 加入Kruskal</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完美AC方法"><span class="nav-number">1.0.1.</span> <span class="nav-text">完美AC方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自动AC机"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">自动AC机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基础暴力算法"><span class="nav-number">1.0.2.</span> <span class="nav-text">基础暴力算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#深度优先搜索（DFS）"><span class="nav-number">1.0.2.1.</span> <span class="nav-text">深度优先搜索（DFS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#广度优先搜索（BFS）"><span class="nav-number">1.0.2.2.</span> <span class="nav-text">广度优先搜索（BFS）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图论"><span class="nav-number">1.0.3.</span> <span class="nav-text">图论</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最短路"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">最短路</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SPFA"><span class="nav-number">1.0.3.1.1.</span> <span class="nav-text">SPFA</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Dijkstra"><span class="nav-number">1.0.3.1.2.</span> <span class="nav-text">Dijkstra</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Floyd"><span class="nav-number">1.0.3.1.3.</span> <span class="nav-text">Floyd</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最小生成树"><span class="nav-number">1.0.3.2.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Prim"><span class="nav-number">1.0.3.2.1.</span> <span class="nav-text">Prim</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Kruskal"><span class="nav-number">1.0.3.2.2.</span> <span class="nav-text">Kruskal</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构"><span class="nav-number">1.0.4.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ST表"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">ST表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并查集"><span class="nav-number">1.0.4.2.</span> <span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树状数组"><span class="nav-number">1.0.4.3.</span> <span class="nav-text">树状数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线段树"><span class="nav-number">1.0.4.4.</span> <span class="nav-text">线段树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lazytag"><span class="nav-number">1.0.5.</span> <span class="nav-text">lazytag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串匹配算法"><span class="nav-number">1.0.6.</span> <span class="nav-text">字符串匹配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#KMP字符串匹配"><span class="nav-number">1.0.6.1.</span> <span class="nav-text">KMP字符串匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AC自动机（好吧，鸽了）"><span class="nav-number">1.0.6.2.</span> <span class="nav-text">AC自动机（好吧，鸽了）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态规划（DP）"><span class="nav-number">1.0.7.</span> <span class="nav-text">动态规划（DP）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#状压DP"><span class="nav-number">1.0.7.1.</span> <span class="nav-text">状压DP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树形DP"><span class="nav-number">1.0.7.2.</span> <span class="nav-text">树形DP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数论"><span class="nav-number">1.0.8.</span> <span class="nav-text">数论</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#素数筛"><span class="nav-number">1.0.8.1.</span> <span class="nav-text">素数筛</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速幂"><span class="nav-number">1.0.8.2.</span> <span class="nav-text">快速幂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#矩阵快速幂"><span class="nav-number">1.0.8.3.</span> <span class="nav-text">矩阵快速幂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#乘法逆元"><span class="nav-number">1.0.8.4.</span> <span class="nav-text">乘法逆元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#欧几里得算法（辗转相除法）"><span class="nav-number">1.0.8.5.</span> <span class="nav-text">欧几里得算法（辗转相除法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#"><span class="nav-number">1.0.8.6.</span> <span class="nav-text"></span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        
<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Konnyaku_ljc</span>

  

  
</div>


<!--  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.7.0</div>
-->




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>



  
  



  
  



  
  



  
  
  <script id="ribbon" size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>





  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/three/three.min.js"></script>

  
  <script src="/lib/three/three-waves.min.js"></script>

  
  <script src="/lib/three/canvas_lines.min.js"></script>

  
  <script src="/lib/three/canvas_sphere.min.js"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  



  











  





  

  

  

  

  

  

  

  

  

  

  

  

  

</body>

   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>

</html>
